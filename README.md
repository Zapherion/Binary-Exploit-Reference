# Binary exploit references

DESCRIPTION

# Tools & Installation


The tools I personally use are:

- GDB with plugins
- Ghidra
- Gef

I installed these tools with the following commands:
```bash
# GDB & Gef
$ apt install gdb
$ apt install gdbserver
$ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh
$ pip3 install ropper keystone-engine unicorn capstone

# Ghidra
$ wget https://ghidra-sre.org/ghidra_9.1.1_PUBLIC_20191218.zip -O /opt/ghidra.zip
$ unzip /opt/ghidra.zip && remove /opt/ghidra.zip
$ apt-get install jdk-default
```

To execute Ghidra a little easier, I made a simple command. Inside /usr/bin I put the file `ghidra` with the following content. This needs the executable bit.
```bash
#!/bin/bash
bash /opt/ghidra/ghidraRun
```
Now I can start Ghidra with the `ghidra` command.

# Useful GDB / Gef Commands

#### Pattern Create
Pattern Create is very useful to detect an offset. Based on the value you enter, a long string will be created with your value as the length, for example 120 characters.
```bash
gef> pattern create <value>
```

#### Pattern Search
Pattern Search is based on the previous command. After you've executed the binary with the previous pattern, you can use pattern search with the wanted register and check at how many bytes you get an exact offset. This is useful to determine how long your "junk" will be.
```bash
gef> pattern search <register>
```

#### VMMap
VMMap tells you the permissions of the binary. If you are able to write on the stack, vmmap will show you this. 
SCREEN
```bash
gef> vmmap
```

#### Checksec
Checksec is used to check which security protections are enabled in the binary.
```bash
gef> checksec
```

# Debugger Registers

REGISTERS INFO ....... WHAT ARE REGISTERS, DIFFERENCE BETWEEN `E` & `R`

RSP = Stack Pointer
RIP = Stack Indicator. This is your next "task".