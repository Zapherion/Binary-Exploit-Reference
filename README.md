# Binary exploit reference

I've been struggling a lot finding a beginners guide to binary exploiting. That's why I've decided to write my own. Keep in mind that I'm by **no** means a pro. I'm still learning this as well.

### Tools & Installation
---

The tools I personally use are:

- GDB with plugins
- Ghidra
- Gef

I installed these tools with the following commands:
```bash
# GDB & Gef
$ apt install gdb
$ apt install gdbserver
$ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh
$ pip3 install ropper keystone-engine unicorn capstone

# Ghidra
$ wget https://ghidra-sre.org/ghidra_9.1.1_PUBLIC_20191218.zip -O /opt/ghidra.zip
$ unzip /opt/ghidra.zip && remove /opt/ghidra.zip
$ apt-get install jdk-default
```

To execute Ghidra a little easier, I made a simple command. Inside /usr/bin I put the file `ghidra` with the following content. This needs the executable bit.
```bash
#!/bin/bash
bash /opt/ghidra/ghidraRun
```
Now I can start Ghidra with the `ghidra` command.

### Useful GDB / Gef Commands
---

#### Pattern Create
Pattern Create is very useful to detect an offset. Based on the value you enter, a long string will be created with your value as the length, for example 120 characters.
```bash
gef> pattern create <value>
```

#### Pattern Search
Pattern Search is based on the previous command. After you've executed the binary with the previous pattern, you can use pattern search with the wanted register and check at how many bytes you get an exact offset. This is useful to determine how long your "junk" will be.
```bash
gef> pattern search <register>
```

#### VMMap
VMMap tells you the permissions of the binary. If you are able to write on the stack, vmmap will show you this. 
SCREEN
```bash
gef> vmmap
```

#### Checksec
Checksec is used to check which security protections are enabled in the binary.
```bash
gef> checksec
```

### Debugger Registers
---

While working on a bufferoverflow with a debugger, you will encounter these registers. It's pretty damn useful to understand what these registers are and what they do.

Registers can begin with either `E` or `R`. The difference between these 2, is the binary bitsize. If the binary is 64 bits, the registers will start with `R`. The stack pointer in this case will be `RSP`. if the binary is 32 bits, registers start with `E`. For example `ESP`.

#### What is a stack?

A stack is a specialized buffer which stores data. Nothing on the stack is code. Data is stored from the top down. So if there is new data to be processed, the old data will push down a little bit.

#### RSP
RSP is the stack pointer. The stack pointer registers stores the address from the last program request in a stack.

#### RIP
RIP is the instruction pointer. This register holds the value of the next instruction that it will execute. This address will be the next task.